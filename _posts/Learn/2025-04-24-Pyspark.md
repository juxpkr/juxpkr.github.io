---
layout: single
title: Pyspark
date: 2025-04-24 16:35:28 +0900
category:
  - learn
tags:
  - 테스트
  - 블로그
toc: "true"
toc_sticky: "true"
---


## 1. Pandas로는 부족했던 이유, Pyspark가 필요한 배경

데이터를 다루는 분석가와 엔지니어에게 Pandas는 익숙하고 강력한 도구이다. 하지만 Pandas는 단일 서버의 메모리 안에서만 데이터를 처리할 수 있는 한계를 가진다. 처리할 데이터의 크기가 서버 메모리를 초과하면, 작업은 불가능해지거나 극도로 느려졌다. 데이터의 규모가 폭발적으로 증가하면서, 이러한 단일 머신 환경의 한계는 빅데이터 분석의 가장 큰 걸림돌이 되었다.

이러한 문제를 해결하기 위해, 분산 컴퓨팅 환경에서 대규모 데이터를 처리하는 프레임워크인 Apache Spark가 등장했다. 그리고 Python 개발자들에서 익숙한 문법으로 Spark를 다룰 수 있게 해주는 도구가 Pyspark이다. Pyspark는 Pandas의 한계를 극복하고, 수십, 수백GB에 달하는 데이터도 효율적으로 처리하는 무기가 된다.

## 2. Pyspark의 구성 요소
Pyspark의 강력함을 이해하기 위해서는 몇 가지 핵심 개념을 알아야 한다. 이 개념들은 Spark가 데이터를 어떻게 처리하고, 분산 환경을 어떻게 관리하는지 보여준다.

### 2.1 SparkSession: 분산 환경의 마에스트로
SparkSession은 Pysparks의 모든 작업이 시작되는 진입점이다. 마치 오케스트라의 지휘자처럼, SparkSession은 분산 환경의 모든 자원을 관리하고, 개발자가 작성한 코드를 실행 가능한 계획으로 바꾼다. 클러스터에 연결하고, 데이터를 읽어 들이며, DataFrame을 생성하는 등 모든 작업은 SparkSession 객체를 통해 이루어진다.

### 2.2 DataFrame: 분산된 데이터 구조체

PySpark의 DataFrame은 Pandas DataFrame과 유사한 테이블 형태의 데이터 구조를 제공한다. 그러나 결정적인 차이가 있다. Pandas DataFrame이 단일 머신 메모리에 모든 데이터를 저장한다면, PySpark DataFrame은 **데이터를 클러스터의 여러 노드에 분산하여 저장**한다. 이 덕분에 대용량 데이터를 처리하는 과정에서 메모리 부족 현상을 겪지 않는다. DataFrame은 데이터를 분산 저장할 뿐만 아니라, 지연 연산(Lazy Evaluation)이라는 특성을 가지고 있어 불필요한 연산을 줄여 성능을 최적화한다.

## 3. PySpark의 두뇌: 카탈리스트 옵티마이저(Catalyst Optimizer)

PySpark가 대규모 데이터를 빠르게 처리하는 가장 큰 이유 중 하나는 **카탈리스트 옵티마이저**에 있다. 이것은 Spark의 쿼리 최적화 엔진으로, 개발자가 작성한 코드를 보고 가장 효율적인 실행 계획을 스스로 수립한다.

카탈리스트 옵티마이저는 세 가지 단계에 걸쳐 작동한다.

### 3.1 논리적 계획(Logical Plan) 생성 
개발자가 작성한 코드(예: `df.filter(...).join(...)`)를 받아서, 어떤 연산을 수행해야 하는지 논리적인 구조를 만든다. 이때는 아직 실제 연산이 시작되지 않는다.

### 3.2 - **논리적 최적화**: 
논리적 계획을 분석하여 더 효율적인 연산 순서를 찾는다. 예를 들어, 조인(Join) 전에 불필요한 데이터를 미리 필터링하여 데이터의 양을 줄이는 '필터 푸시다운(Filter Pushdown)' 같은 최적화를 수행한다.

### 3.3 1. **물리적 계획(Physical Plan) 생성**: 
최적화된 논리적 계획을 바탕으로, Spark 클러스터에서 실제로 연산을 수행할 가장 효율적인 방법을 결정한다.

이러한 과정을 통해 PySpark는 개발자가 작성한 코드를 그대로 실행하는 것이 아니라, 내부적으로 가장 빠르고 효율적인 실행 계획을 만들어내어 처리 속도를 혁신적으로 향상시킨다.


## 4. PySpark의 원리가 실무에서 발휘되는 지점


카탈리스트 옵티마이저의 원리는 실제 데이터 전처리 작업에서 빛을 발한다.

- **복잡한 조인(Join) 최적화**: 두 개의 대용량 DataFrame을 조인할 때, 옵티마이저는 데이터의 크기와 분포를 고려하여 가장 효율적인 조인 알고리즘(예: Broadcast Join)을 선택한다. 이 덕분에 개발자가 복잡하게 코드를 작성하지 않아도 최상의 성능을 얻을 수 있다.
    
- **결측치 처리 및 필터링**: 결측치를 처리하거나 특정 조건에 따라 데이터를 필터링하는 연산은, 옵티마이저에 의해 데이터가 클러스터의 각 노드에 분산된 상태에서 효율적으로 처리된다. 이를 통해 메모리 부족 없이 대규모 데이터셋을 깔끔하게 정리할 수 있다.
    

이처럼 PySpark는 단순한 라이브러리를 넘어, 분산 처리의 복잡성을 추상화하여 데이터 엔지니어가 데이터의 '무게'에 짓눌리지 않고 분석에 집중할 수 있게 하는 강력한 무기가 된다.

