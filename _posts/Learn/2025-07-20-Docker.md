---
layout: single
title: 무제
date: 2025-07-20 00:39:46 +0900
category:
  - learn
tags:
  - 테스트
  - 블로그
toc: "true"
toc_sticky: "true"
---
내가 Docker를 공부하며 깨달은 것

### 1. Intro : "제 컴퓨터에서는 잘 되는데요?"
소프트웨어 개발에서 코드 자체만큼이나 중요한 것은 코드가 실행되는 환경이다. 개발자의 로컬 환경, 테스트 서버, 그리고 실제 운영 서버의 환경이 미세하게 다를 때, 예측 불가능한 오류가 발생할 수 있다. 특정 라이브러리의 부재, 버전의 불일치, OS 설정의 차이 같은 문제들은 디버깅에 많은 시간을 소모하게 만들 수 있다.

이런 시간 낭비는 프로젝트의 생산성을 상당히 저해하는 부분이었고, 코드를 작성하는 시간보다 환경을 맞추는 데 더 많은 노력을 기울이는 비효율은 반드시 해결해야 할 문제라고 판단했다.

이 문제를 해결하기 위해, 나는 코드와 실행 환경을 하나로 묶어 이식성을 극대화하는 Docker 도입을 결정했다. 나의 목표는 어떤 인프라 위에서든 동일한 방식으로 소프트웨어를 실행하여 예측 가능성을 확보하는 것이었다.
### 2. 도커의 핵심 원리
도커를 처음 접하고 이미지, 컨테이너 같은 낯선 단어들에 겁을 먹을 것이다. 나는 이 개념을 냉동만두에 비유하여 이해했다.
- 이미지(Image)는 냉동만두다: 
  만두소, 만두피, 그리고 만두를 찌는 데 필요한 모든 재료와 레시피가 완벽하게 계량되어 하나의 패키지로 '얼려진'상태다. 이 냉동 만두는 그 자체로 먹을 순 없지만, 이 패키지만 있으면 누가, 언제, 어디서 찌든 항상 똑같은 맛의 만두를 만들 수 있다.
- 컨테이너(Container)는 '갓 쪄낸 만두'다:
  '냉동 만두(Image)'를 찜기에 넣고 실제로 쪄서, 김이 모락모락 나는 먹을 수 있는 상태가 바로 '컨테이너'다. 이 찐만두는 찜기라는 격리된 공간 안에서 조리되기 때문에, 바깥세상(내 컴퓨터의 다른 프로그램들)과 전혀 섞이지 않는다. 우리는 수십 개의 찜기(컨테이너)를 동시에 돌려도, 서로의 맛에 영향을 주지 않는 완벽한 '격리'를 보장받는다.
- Dockerfile은 '만두 레시피'다:
  어떤 재료를 쓰고, 어떤 순서로 조리할지 상세하게 적어놓은 레시피. Docker는 이 Dockerfile을 읽어서, 나만의 커스텀 '냉동 만주(Image)'를 만들어낸다.
- Docer Compost는 코스요리 주문서다:
  만두(Kafka), 볶음밥(Spark), 탕수육(Airflow)을 함께 먹고 싶을 때, 만두 먼저 쪄주시고, 밥 볶아서, 탕수육이랑 같이 내주세요 라고 한번에 주문하는 것과 같다. docker-compose.yml파일에 우리가 필요한 서비스들의 목록과 순서를 적어두면, docker-compose up이라는 명령어 한방에 전체 코스 요리(데이터 파이프라인)가 차려진다.

### 3. 나의 첫번째 장애물: 컨테이너는 외딴 섬이었다.
개념을 이해했다고 생각하고, 우리 프로젝트의 파이프라인을 로컬에 구축하기 시작했다. Kafka를 하나의 컨테이너에, 데이터를 보내는 Producer를 또 다른 컨테이너에 띄웠다. 그리고 Producer를 실행시킨 순간, 나는 절망적인 에러 메시지를 만났다.
`Connection Refused`, `NoBrokersAvailable`
분명 Kafka 컨테이너는 잘 돌고 있는데, 왜 Producer는 Kafka를 찾지 못하는 걸까? 몇 시간을 헤멘 끝에 깨달은 사실은, 컨테이너는 각자 자신만의 localhost를 가진 외딴 섬 이라는 것이었다. 내가 사는 아파트 안에, Kafka의 집과 Producer의 집이 따로따로 있는데, Producer가 자기 집 안에서만 엄마(localhost)를 외치니, 옆집에 있는 Kafka에게 목소리가 들릴 리가 없었던 것이다.

원인은 나의 무지함, 즉 Docker의 네트워크 개념을 이해하지 못했기 때문이었다. 해결책은 Docker Compose를 통해 두 컨테이너가 함께 소통할 수 있는 공용 네트워크를 만들어주고, Kafka의 설정(advertised.listeners)에 내 실제 주소는 이 공용 네트워크의 'kafka'라는 이름이야! 라고 명확히 알려주는 것이었다.

이 장애물을 넘는 순간, 도커는 나에게 더 이상 격리도구가 아니라 소통하는 서비스들의 도시를 설계하는 도구로 다가왔다.

### 4. 결론
도커는 단순히 프로그램을 포장하는 기술이 아니었다. 그것은 환경의 차이라는 개발의 가장 근본적인 문제를 해결하고, 복잡한 서비스들을 격리함으로써 오히려 더 안정적으로 연결되게 만드는 설계 철학이었다.
다음 글에서는 이렇게 도커라는 도시 위에 우리가 세운 첫 번쨰 건물, 데이터 파이프라인의 대동맥 kafka에 대해 이야기 해보려한다.